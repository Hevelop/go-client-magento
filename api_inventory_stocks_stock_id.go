/*
Commerce Admin REST endpoints - All inclusive

The schemas documented here are autogenerated from an instance of Adobe Commerce with B2B. Each schema represents a specific user role (Admin, Customer, and Guest) and determines which endpoints are accessible. Use the version switcher to select an Adobe Commerce version and corresponding API.  You can also <a href=\"https://developer.adobe.com/commerce/webapi/rest/quick-reference/generate-local\" target=\"_blank\">generate a local API reference</a> based on your own Adobe Commerce configuration, which allows you to see API documentation for your specific Adobe Commerce modules, third-party modules, and extension attributes.

API version: 2.4.7
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package magento

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type InventoryStocksStockIdAPI interface {

	/*
		DeleteV1InventoryStocksStockId inventory/stocks/{stockId}

		Delete the Stock data by stockId. If stock is not found do nothing

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param stockId
		@return ApiDeleteV1InventoryStocksStockIdRequest
	*/
	DeleteV1InventoryStocksStockId(ctx context.Context, stockId int32) ApiDeleteV1InventoryStocksStockIdRequest

	// DeleteV1InventoryStocksStockIdExecute executes the request
	//  @return ErrorResponse
	DeleteV1InventoryStocksStockIdExecute(r ApiDeleteV1InventoryStocksStockIdRequest) (*ErrorResponse, *http.Response, error)

	/*
		GetV1InventoryStocksStockId inventory/stocks/{stockId}

		Get Stock data by given stockId. If you want to create plugin on get method, also you need to create separate plugin on getList method, because entity loading way is different for these methods

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param stockId
		@return ApiGetV1InventoryStocksStockIdRequest
	*/
	GetV1InventoryStocksStockId(ctx context.Context, stockId int32) ApiGetV1InventoryStocksStockIdRequest

	// GetV1InventoryStocksStockIdExecute executes the request
	//  @return InventoryApiDataStockInterface
	GetV1InventoryStocksStockIdExecute(r ApiGetV1InventoryStocksStockIdRequest) (*InventoryApiDataStockInterface, *http.Response, error)

	/*
		PutV1InventoryStocksStockId inventory/stocks/{stockId}

		Save Stock data

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param stockId
		@return ApiPutV1InventoryStocksStockIdRequest
	*/
	PutV1InventoryStocksStockId(ctx context.Context, stockId string) ApiPutV1InventoryStocksStockIdRequest

	// PutV1InventoryStocksStockIdExecute executes the request
	//  @return int32
	PutV1InventoryStocksStockIdExecute(r ApiPutV1InventoryStocksStockIdRequest) (int32, *http.Response, error)
}

// InventoryStocksStockIdAPIService InventoryStocksStockIdAPI service
type InventoryStocksStockIdAPIService service

type ApiDeleteV1InventoryStocksStockIdRequest struct {
	ctx        context.Context
	ApiService InventoryStocksStockIdAPI
	stockId    int32
}

func (r ApiDeleteV1InventoryStocksStockIdRequest) Execute() (*ErrorResponse, *http.Response, error) {
	return r.ApiService.DeleteV1InventoryStocksStockIdExecute(r)
}

/*
DeleteV1InventoryStocksStockId inventory/stocks/{stockId}

Delete the Stock data by stockId. If stock is not found do nothing

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stockId
	@return ApiDeleteV1InventoryStocksStockIdRequest
*/
func (a *InventoryStocksStockIdAPIService) DeleteV1InventoryStocksStockId(ctx context.Context, stockId int32) ApiDeleteV1InventoryStocksStockIdRequest {
	return ApiDeleteV1InventoryStocksStockIdRequest{
		ApiService: a,
		ctx:        ctx,
		stockId:    stockId,
	}
}

// Execute executes the request
//
//	@return ErrorResponse
func (a *InventoryStocksStockIdAPIService) DeleteV1InventoryStocksStockIdExecute(r ApiDeleteV1InventoryStocksStockIdRequest) (*ErrorResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ErrorResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryStocksStockIdAPIService.DeleteV1InventoryStocksStockId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/V1/inventory/stocks/{stockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"stockId"+"}", url.PathEscape(parameterValueToString(r.stockId, "stockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetV1InventoryStocksStockIdRequest struct {
	ctx        context.Context
	ApiService InventoryStocksStockIdAPI
	stockId    int32
}

func (r ApiGetV1InventoryStocksStockIdRequest) Execute() (*InventoryApiDataStockInterface, *http.Response, error) {
	return r.ApiService.GetV1InventoryStocksStockIdExecute(r)
}

/*
GetV1InventoryStocksStockId inventory/stocks/{stockId}

Get Stock data by given stockId. If you want to create plugin on get method, also you need to create separate plugin on getList method, because entity loading way is different for these methods

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stockId
	@return ApiGetV1InventoryStocksStockIdRequest
*/
func (a *InventoryStocksStockIdAPIService) GetV1InventoryStocksStockId(ctx context.Context, stockId int32) ApiGetV1InventoryStocksStockIdRequest {
	return ApiGetV1InventoryStocksStockIdRequest{
		ApiService: a,
		ctx:        ctx,
		stockId:    stockId,
	}
}

// Execute executes the request
//
//	@return InventoryApiDataStockInterface
func (a *InventoryStocksStockIdAPIService) GetV1InventoryStocksStockIdExecute(r ApiGetV1InventoryStocksStockIdRequest) (*InventoryApiDataStockInterface, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InventoryApiDataStockInterface
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryStocksStockIdAPIService.GetV1InventoryStocksStockId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/V1/inventory/stocks/{stockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"stockId"+"}", url.PathEscape(parameterValueToString(r.stockId, "stockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutV1InventoryStocksStockIdRequest struct {
	ctx                          context.Context
	ApiService                   InventoryStocksStockIdAPI
	stockId                      string
	postV1InventoryStocksRequest *PostV1InventoryStocksRequest
}

func (r ApiPutV1InventoryStocksStockIdRequest) PostV1InventoryStocksRequest(postV1InventoryStocksRequest PostV1InventoryStocksRequest) ApiPutV1InventoryStocksStockIdRequest {
	r.postV1InventoryStocksRequest = &postV1InventoryStocksRequest
	return r
}

func (r ApiPutV1InventoryStocksStockIdRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.PutV1InventoryStocksStockIdExecute(r)
}

/*
PutV1InventoryStocksStockId inventory/stocks/{stockId}

Save Stock data

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param stockId
	@return ApiPutV1InventoryStocksStockIdRequest
*/
func (a *InventoryStocksStockIdAPIService) PutV1InventoryStocksStockId(ctx context.Context, stockId string) ApiPutV1InventoryStocksStockIdRequest {
	return ApiPutV1InventoryStocksStockIdRequest{
		ApiService: a,
		ctx:        ctx,
		stockId:    stockId,
	}
}

// Execute executes the request
//
//	@return int32
func (a *InventoryStocksStockIdAPIService) PutV1InventoryStocksStockIdExecute(r ApiPutV1InventoryStocksStockIdRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InventoryStocksStockIdAPIService.PutV1InventoryStocksStockId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/V1/inventory/stocks/{stockId}"
	localVarPath = strings.Replace(localVarPath, "{"+"stockId"+"}", url.PathEscape(parameterValueToString(r.stockId, "stockId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/xml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postV1InventoryStocksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
